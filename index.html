<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Detector ‚Äú¬øest√° en su lugar?‚Äù ‚Äî iPhone/Android</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0b1020"/>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <style>
    :root { --ok:#10b981; --bad:#ef4444; --bg:#0b1020; --fg:#e5e7eb; --muted:#94a3b8; }
    * { box-sizing: border-box; }
    body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
    .wrap{max-width:1100px;margin:env(safe-area-inset-top) auto env(safe-area-inset-bottom);padding:16px}
    h1{font-size:20px;margin:0 0 12px}
    .grid{display:grid;grid-template-columns:1.1fr .9fr;gap:16px}
    @media (max-width: 900px){ .grid{grid-template-columns:1fr} }
    .card{background:#0f172a;border:1px solid #1f2937;border-radius:16px;padding:12px;box-shadow:0 6px 24px rgba(0,0,0,.25)}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin:8px 0}
    label{font-size:13px;color:var(--muted)}
    button{background:#1f2937;color:var(--fg);border:1px solid #374151;border-radius:12px;padding:10px 14px;cursor:pointer}
    button:disabled{opacity:.45;cursor:not-allowed}
    input[type="range"]{width:180px}
    .status{font-weight:700;padding:8px 12px;border-radius:999px;display:inline-flex;align-items:center;gap:8px}
    .ok{background:rgba(16,185,129,.15);color:var(--ok);border:1px solid rgba(16,185,129,.35)}
    .bad{background:rgba(239,68,68,.15);color:var(--bad);border:1px solid rgba(239,68,68,.35)}
    .pill{font-size:12px;color:var(--muted);padding:4px 8px;border:1px dashed #334155;border-radius:999px}
    canvas{width:100%;border-radius:12px;background:#0b1220;touch-action:none} /* <- imprescindible en iOS */
    .small{font-size:12px;color:var(--muted)}
    .kbd{background:#111827;border:1px solid #374151;border-radius:6px;padding:2px 6px;font-family:ui-monospace,monospace;font-size:12px}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Detector ‚Äú¬øest√° en su lugar?‚Äù ‚Äî iPhone/Android</h1>

    <div class="grid">
      <!-- C√°mara / Live -->
      <div class="card">
        <div class="row">
          <span id="opencvStatus" class="pill">Cargando OpenCV‚Ä¶</span>
          <span id="runStatus" class="status ok" style="display:none;">Listo</span>
          <span id="alertStatus" class="status bad" style="display:none;">FUERA DE SITIO</span>
        </div>
        <div class="row">
          <button id="btnStart" disabled>Empezar c√°mara</button>
          <button id="btnSwitch" disabled>üîÑ Cambiar c√°mara</button>
          <button id="btnStop" disabled>Detener</button>
          <label class="small"><input type="checkbox" id="chkBeep" checked> Beep</label>
          <label class="small"><input type="checkbox" id="chkDebug" checked> Debug</label>
        </div>
        <div class="row">
          <label>Umbral: <span id="thVal">0.80</span></label>
          <input type="range" id="threshold" min="0.50" max="0.98" step="0.01" value="0.80">
          <label>Tolerancia: <span id="tolVal">40</span> px</label>
          <input type="range" id="tolerance" min="10" max="200" step="2" value="40">
        </div>
        <video id="video" playsinline webkit-playsinline muted style="display:none"></video>
        <canvas id="canvasLive" width="960" height="540"></canvas>
        <p class="small">Puedes iniciar la c√°mara y dibujar la zona despu√©s. Si sale la frontal, pulsa üîÑ.</p>
      </div>

      <!-- Referencia -->
      <div class="card">
        <div class="row">
          <input id="refFile" type="file" accept="image/*;capture=camera">
          <button id="btnDraw" disabled>‚úèÔ∏è Dibujar zona esperada</button>
          <button id="btnClearROI" disabled>Limpiar zona</button>
        </div>
        <canvas id="canvasRef" width="640" height="360" title="Sube la foto y dibuja la zona"></canvas>
        <p class="small">
          1) Sube foto con el objeto ‚Äúen su sitio‚Äù.<br>
          2) Pulsa <span class="kbd">Dibujar zona</span> y arrastra con el dedo para marcar el rect√°ngulo.
        </p>
        <div class="row">
          <span class="pill">Template: <span id="tplInfo">‚Äî</span></span>
          <span class="pill">FPS: <span id="fpsInfo">‚Äî</span></span>
          <span class="pill">Score: <span id="scoreInfo">‚Äî</span></span>
          <span class="pill">Dist: <span id="distInfo">‚Äî</span></span>
        </div>
      </div>
    </div>
  </div>

  <!-- OpenCV.js -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  <script>
    // --------- Estado global ----------
    let cvReady=false, drawingROI=false, roi=null, templateMat=null, expectedCenter=null;
    let running=false, timer=null, lastAlert=false, fpsCounter={t0:performance.now(),frames:0};
    let currentStream=null, currentFacing='environment', cachedDeviceIds={ user:null, environment:null };

    // Referencia base para poder limpiar correctamente y dibujar siempre sobre la foto
    let refImg=null;     // Image()
    let refDraw=null;    // {x,y,w,h} d√≥nde se dibuja la imagen dentro del canvas

    // DOM
    const opencvStatus=document.getElementById('opencvStatus');
    const runStatus=document.getElementById('runStatus');
    const alertStatus=document.getElementById('alertStatus');
    const btnStart=document.getElementById('btnStart');
    const btnSwitch=document.getElementById('btnSwitch');
    const btnStop=document.getElementById('btnStop');
    const chkBeep=document.getElementById('chkBeep');
    const chkDebug=document.getElementById('chkDebug');
    const threshold=document.getElementById('threshold');
    const thVal=document.getElementById('thVal');
    const tolerance=document.getElementById('tolerance');
    const tolVal=document.getElementById('tolVal');
    const refFile=document.getElementById('refFile');
    const btnDraw=document.getElementById('btnDraw');
    const btnClearROI=document.getElementById('btnClearROI');
    const canvasRef=document.getElementById('canvasRef');
    const ctxRef=canvasRef.getContext('2d');
    const canvasLive=document.getElementById('canvasLive');
    const ctxLive=canvasLive.getContext('2d');
    const video=document.getElementById('video');
    const tplInfo=document.getElementById('tplInfo');
    const fpsInfo=document.getElementById('fpsInfo');
    const scoreInfo=document.getElementById('scoreInfo');
    const distInfo=document.getElementById('distInfo');

    thVal.textContent=Number(threshold.value).toFixed(2);
    tolVal.textContent=tolerance.value;
    threshold.addEventListener('input',()=> thVal.textContent=Number(threshold.value).toFixed(2));
    tolerance.addEventListener('input',()=> tolVal.textContent=tolerance.value);

    // --------- Helpers referencia ----------
    function drawRefBase(){
      const {width, height} = canvasRef;
      ctxRef.clearRect(0,0,width,height);
      if (refImg && refDraw){
        ctxRef.drawImage(refImg, refDraw.x, refDraw.y, refDraw.w, refDraw.h);
      }
    }
    function updateROIOverlay(){
      drawRefBase(); // redibuja la foto limpia
      if (roi){
        ctxRef.save();
        ctxRef.strokeStyle='rgba(16,185,129,.9)';
        ctxRef.lineWidth=2; ctxRef.setLineDash([6,4]);
        ctxRef.strokeRect(roi.x, roi.y, roi.w, roi.h);
        ctxRef.restore();
      }
    }

    // --------- Audio (beep) y desbloqueo iOS ----------
    let audioUnlocked=false;
    function ensureAudioUnlocked(){
      if (audioUnlocked) return;
      try{
        const ac=new (window.AudioContext||window.webkitAudioContext)();
        if (ac.state==='suspended') ac.resume();
        const o=ac.createOscillator(), g=ac.createGain();
        o.connect(g); g.connect(ac.destination); o.start(0); o.stop(0); ac.close();
        audioUnlocked=true;
      }catch(e){}
    }
    function beep(){
      if (!chkBeep.checked) return;
      try{
        const ac=new (window.AudioContext||window.webkitAudioContext)();
        const o=ac.createOscillator(), g=ac.createGain();
        o.connect(g); g.connect(ac.destination); o.type='square'; o.frequency.value=880; g.gain.value=0.05;
        o.start(); setTimeout(()=>{ o.stop(); ac.close(); },160);
      }catch(e){}
    }

    // --------- Cargar foto de referencia ----------
    refFile.addEventListener('change',(e)=>{
      const file=e.target.files?.[0]; if (!file) return;
      const img=new Image();
      img.onload=()=>{
        // encajar manteniendo proporci√≥n dentro del canvasRef
        const scale=Math.min(canvasRef.width/img.width, canvasRef.height/img.height);
        const w=img.width*scale, h=img.height*scale;
        const x=(canvasRef.width - w)/2, y=(canvasRef.height - h)/2;

        refImg = img;
        refDraw = {x,y,w,h};
        drawRefBase();

        roi=null; expectedCenter=null;
        btnDraw.disabled=false; btnClearROI.disabled=false; tplInfo.textContent='‚Äî';
        if (templateMat){ templateMat.delete(); templateMat=null; }
      };
      img.src=URL.createObjectURL(file);
    });

    // --------- Dibujo ROI (pointer + fallback touch) con coordenadas escaladas ----------
    let dragStart=null;
    function getPos(ev,canvas){
      const r=canvas.getBoundingClientRect();
      // Ajuste por escalado CSS y devicePixelRatio
      const scaleX = canvas.width  / r.width;
      const scaleY = canvas.height / r.height;
      const touch = ev.touches && ev.touches[0];
      const cx = touch ? touch.clientX : ev.clientX;
      const cy = touch ? touch.clientY : ev.clientY;
      return { x: (cx - r.left) * scaleX, y: (cy - r.top) * scaleY };
    }

    canvasRef.addEventListener('pointerdown',(ev)=>{
      if (!drawingROI) return;
      canvasRef.setPointerCapture(ev.pointerId);
      dragStart = getPos(ev, canvasRef);
    });
    canvasRef.addEventListener('pointermove',(ev)=>{
      if (!drawingROI || !dragStart) return;
      const p = getPos(ev, canvasRef);
      const x=Math.min(dragStart.x, p.x);
      const y=Math.min(dragStart.y, p.y);
      const w=Math.abs(p.x - dragStart.x);
      const h=Math.abs(p.y - dragStart.y);
      roi = {x,y,w,h};
      updateROIOverlay();
    });
    canvasRef.addEventListener('pointerup',(ev)=>{
      if (!drawingROI || !roi || roi.w<10 || roi.h<10){ dragStart=null; return; }
      try{ canvasRef.releasePointerCapture(ev.pointerId); }catch(_){}
      drawingROI=false; btnDraw.textContent='‚úèÔ∏è Dibujar zona esperada'; dragStart=null;

      // Aseg√∫rate de no capturar el overlay dentro de la plantilla
      drawRefBase();
      if (templateMat){ templateMat.delete(); templateMat=null; }
      const src=cv.imread(canvasRef);
      let tpl=src.roi(new cv.Rect(Math.round(roi.x),Math.round(roi.y),Math.round(roi.w),Math.round(roi.h)));
      cv.cvtColor(tpl,tpl,cv.COLOR_RGBA2GRAY);
      cv.GaussianBlur(tpl,tpl,new cv.Size(3,3),0);
      templateMat=tpl; src.delete();
      expectedCenter={ x: roi.x+roi.w/2, y: roi.y+roi.h/2 };
      tplInfo.textContent=`${templateMat.cols}√ó${templateMat.rows}`;
      updateROIOverlay();
    });

    // Fallback touch (por si acaso)
    canvasRef.addEventListener('touchstart',(ev)=>{ if(!drawingROI) return; ev.preventDefault(); dragStart=getPos(ev,canvasRef); },{passive:false});
    canvasRef.addEventListener('touchmove',(ev)=>{ if(!drawingROI||!dragStart) return; ev.preventDefault();
      const p=getPos(ev,canvasRef);
      const x=Math.min(dragStart.x,p.x), y=Math.min(dragStart.y,p.y);
      const w=Math.abs(p.x-dragStart.x), h=Math.abs(p.y-dragStart.y);
      roi={x,y,w,h}; updateROIOverlay();
    },{passive:false});
    canvasRef.addEventListener('touchend',(ev)=>{ if(!drawingROI||!roi||roi.w<10||roi.h<10){ dragStart=null; return; }
      drawingROI=false; btnDraw.textContent='‚úèÔ∏è Dibujar zona esperada'; dragStart=null;

      drawRefBase();
      if (templateMat){ templateMat.delete(); templateMat=null; }
      const src=cv.imread(canvasRef);
      let tpl=src.roi(new cv.Rect(Math.round(roi.x),Math.round(roi.y),Math.round(roi.w),Math.round(roi.h)));
      cv.cvtColor(tpl,tpl,cv.COLOR_RGBA2GRAY); cv.GaussianBlur(tpl,tpl,new cv.Size(3,3),0);
      templateMat=tpl; src.delete();
      expectedCenter={ x: roi.x+roi.w/2, y: roi.y+roi.h/2 };
      tplInfo.textContent=`${templateMat.cols}√ó${templateMat.rows}`;
      updateROIOverlay();
    },{passive:false});

    btnDraw.addEventListener('click',()=>{
      drawingROI = !drawingROI;
      btnDraw.textContent = drawingROI ? '‚úÖ Terminar dibujo' : '‚úèÔ∏è Dibujar zona esperada';
    });

    btnClearROI.addEventListener('click', ()=>{
      roi=null; expectedCenter=null;
      if (templateMat){ templateMat.delete(); templateMat=null; }
      tplInfo.textContent='‚Äî';
      drawRefBase(); // limpieza real
    });

    // --------- C√°mara (iOS-friendly) ----------
    async function stopStream(){ if(currentStream){ currentStream.getTracks().forEach(t=>t.stop()); } currentStream=null; }
    async function listCameras(){
      try{
        const devices=await navigator.mediaDevices.enumerateDevices();
        devices.filter(d=>d.kind==='videoinput').forEach(d=>{
          const label=(d.label||'').toLowerCase();
          if (label.includes('back')||label.includes('rear')) cachedDeviceIds.environment=d.deviceId;
          if (label.includes('front')) cachedDeviceIds.user=d.deviceId;
        });
      }catch(e){}
    }
    async function startCamera(prefer='environment'){
      await stopStream();
      ensureAudioUnlocked();
      let constraints={ video:{ facingMode: prefer }, audio:false };
      const devId=cachedDeviceIds[prefer];
      if (devId) constraints.video = { deviceId:{ exact: devId } };
      try{
        const stream=await navigator.mediaDevices.getUserMedia(constraints);
        currentStream=stream; video.srcObject=stream; await video.play();
        await listCameras(); btnSwitch.disabled=false; return true;
      }catch(e){
        try{
          const stream=await navigator.mediaDevices.getUserMedia({ video:true, audio:false });
          currentStream=stream; video.srcObject=stream; await video.play();
          await listCameras(); btnSwitch.disabled=false; return true;
        }catch(err){
          alert('No se pudo acceder a la c√°mara. iOS: Ajustes ‚Üí Safari ‚Üí C√°mara ‚Üí Permitir.');
          return false;
        }
      }
    }

    btnStart.addEventListener('click', async ()=>{
      if (!cvReady){ alert('OpenCV a√∫n est√° cargando.'); return; }
      btnStart.disabled=true; btnSwitch.disabled=true;
      if (await startCamera(currentFacing)){ btnStop.disabled=false; runStatus.style.display='inline-flex'; startLoop(); }
      else { btnStart.disabled=false; }
    });
    btnSwitch.addEventListener('click', async ()=>{ currentFacing=(currentFacing==='environment')?'user':'environment'; await startCamera(currentFacing); });
    btnStop.addEventListener('click', async ()=>{ stopLoop(); await stopStream(); video.srcObject=null; btnStop.disabled=true; btnStart.disabled=false; runStatus.style.display='none'; alertStatus.style.display='none'; });

    function startLoop(){ running=true; lastAlert=false; fpsCounter={t0:performance.now(),frames:0}; if(timer) clearInterval(timer); timer=setInterval(processFrame,100); }
    function stopLoop(){ running=false; if(timer){ clearInterval(timer); timer=null; } }

    function drawExpectedBox(ctx){
      if (!roi) return;
      ctx.save(); ctx.strokeStyle='rgba(59,130,246,.9)'; ctx.lineWidth=2; ctx.setLineDash([6,4]);
      const rx=roi.x*(canvasLive.width/canvasRef.width),
            ry=roi.y*(canvasLive.height/canvasRef.height),
            rw=roi.w*(canvasLive.width/canvasRef.width),
            rh=roi.h*(canvasLive.height/canvasRef.height);
      ctx.strokeRect(rx,ry,rw,rh); ctx.restore();
    }

    function processFrame(){
      if(!running) return;
      const W=canvasLive.width,H=canvasLive.height;
      ctxLive.drawImage(video,0,0,W,H);

      // Si no hay plantilla a√∫n, solo muestra la caja esperada (si existe)
      if (!templateMat){ drawExpectedBox(ctxLive); return; }

      let frame=cv.imread(canvasLive), gray=new cv.Mat();
      cv.cvtColor(frame,gray,cv.COLOR_RGBA2GRAY); cv.GaussianBlur(gray,gray,new cv.Size(3,3),0);
      const resultCols=gray.cols-templateMat.cols+1, resultRows=gray.rows-templateMat.rows+1;
      if(resultCols<1||resultRows<1){ frame.delete(); gray.delete(); return; }
      let result=new cv.Mat(resultRows,resultCols,cv.CV_32FC1);
      cv.matchTemplate(gray,templateMat,result,cv.TM_CCOEFF_NORMED);
      let mm=cv.minMaxLoc(result); const best=mm.maxLoc, score=mm.maxVal;

      if (chkDebug.checked){
        ctxLive.save();
        ctxLive.strokeStyle='rgba(16,185,129,.9)';
        ctxLive.lineWidth=2; ctxLive.setLineDash([]);
        ctxLive.strokeRect(best.x,best.y,templateMat.cols,templateMat.rows);
        ctxLive.restore();
      }
      drawExpectedBox(ctxLive);

      const bestCenter={x:best.x+templateMat.cols/2,y:best.y+templateMat.rows/2};
      let exp={ x: expectedCenter? expectedCenter.x*(canvasLive.width/canvasRef.width):bestCenter.x,
                y: expectedCenter? expectedCenter.y*(canvasLive.height/canvasRef.height):bestCenter.y };
      const dx=bestCenter.x-exp.x, dy=bestCenter.y-exp.y, dist=Math.hypot(dx,dy);
      const ok=(score>=Number(threshold.value))&&(dist<=Number(tolerance.value));
      alertStatus.style.display = ok ? 'none':'inline-flex';
      if(!ok && !lastAlert) beep(); lastAlert=!ok;

      scoreInfo.textContent=score.toFixed(3);
      distInfo.textContent=Math.round(dist)+' px';

      fpsCounter.frames++; const t1=performance.now();
      if(t1-fpsCounter.t0>=1000){ fpsInfo.textContent=fpsCounter.frames+' fps'; fpsCounter.frames=0; fpsCounter.t0=t1; }

      frame.delete(); gray.delete(); result.delete();
    }

    // --------- OpenCV init ----------
    window.Module = {
      onRuntimeInitialized(){ cvReady=true; opencvStatus.textContent='OpenCV listo'; btnStart.disabled=false; }
    };
  </script>
</body>
</html>
